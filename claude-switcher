#!/usr/bin/env python3
"""
Claude Code Switcher - Manage multiple model profiles and launch isolated sessions
"""

import json
import os
import sys
import subprocess
import shutil
import time
import signal
from pathlib import Path
from typing import Dict, Any, Optional, List
from datetime import datetime
from urllib.parse import urlparse

VERSION = "2.2.0"
GITHUB_REPO = "rolan86/claude-code-switcher"

CONFIG_DIR = Path.home() / ".claude-switcher"
PROFILES_FILE = CONFIG_DIR / "profiles.json"
ALIASES_FILE = CONFIG_DIR / "aliases.json"
SESSIONS_FILE = CONFIG_DIR / "sessions.json"
GROUPS_FILE = CONFIG_DIR / "groups.json"
LOGS_DIR = CONFIG_DIR / "logs"
BACKUPS_DIR = CONFIG_DIR / "backups"
WORKSPACE_FILE = ".claude-switcher.json"

class ProfileManager:
    def __init__(self):
        self.config_dir = CONFIG_DIR
        self.profiles_file = PROFILES_FILE
        self._ensure_config_exists()

    def _ensure_config_exists(self):
        """Create config directory and default profiles file if they don't exist"""
        self.config_dir.mkdir(exist_ok=True)
        LOGS_DIR.mkdir(exist_ok=True)
        BACKUPS_DIR.mkdir(exist_ok=True)

        if not self.profiles_file.exists():
            default_config = {
                "profiles": {},
                "default_profile": None
            }
            self._save_config(default_config)

    def _load_config(self) -> Dict[str, Any]:
        """Load profiles configuration"""
        with open(self.profiles_file, 'r') as f:
            return json.load(f)

    def _save_config(self, config: Dict[str, Any]):
        """Save profiles configuration"""
        with open(self.profiles_file, 'w') as f:
            json.dump(config, f, indent=2)

    def add_profile(self, name: str, interactive: bool = True):
        """Add a new profile"""
        config = self._load_config()

        if name in config['profiles']:
            response = input(f"Profile '{name}' already exists. Overwrite? (y/n): ")
            if response.lower() != 'y':
                print("Aborted.")
                return

        profile = {}

        if interactive:
            print(f"\n=== Creating profile: {name} ===")

            # API Key
            api_key = input("API Key (or Auth Token): ").strip()
            profile['api_key'] = api_key

            # Base URL
            print("\nBase URL (press Enter for default Anthropic):")
            print("  - Anthropic (default): https://api.anthropic.com")
            print("  - Z.AI GLM: https://api.z.ai/api/anthropic")
            print("  - Custom: Enter your URL")
            base_url = input("Base URL: ").strip()
            profile['base_url'] = base_url if base_url else "https://api.anthropic.com"

            # Model mappings
            print("\nModel mappings (press Enter to skip):")
            profile['models'] = {}

            for tier in ['haiku', 'sonnet', 'opus']:
                model = input(f"  {tier.capitalize()} model: ").strip()
                if model:
                    profile['models'][tier] = model

        config['profiles'][name] = profile

        # Set as default if it's the first profile
        if not config['default_profile']:
            config['default_profile'] = name
            print(f"\nSet '{name}' as default profile")

        self._save_config(config)
        print(f"\nâœ“ Profile '{name}' saved successfully!")

    def list_profiles(self):
        """List all profiles"""
        config = self._load_config()

        if not config['profiles']:
            print("No profiles configured. Use 'claude-switcher profile add <name>' to create one.")
            return

        print("\n=== Configured Profiles ===\n")
        for name, profile in config['profiles'].items():
            is_default = " (default)" if name == config['default_profile'] else ""
            print(f"â€¢ {name}{is_default}")
            print(f"  Base URL: {profile.get('base_url', 'N/A')}")
            if profile.get('models'):
                print(f"  Models: {', '.join(f'{k}={v}' for k, v in profile['models'].items())}")
            print()

    def remove_profile(self, name: str):
        """Remove a profile"""
        config = self._load_config()

        if name not in config['profiles']:
            print(f"Error: Profile '{name}' not found")
            sys.exit(1)

        del config['profiles'][name]

        # Update default if needed
        if config['default_profile'] == name:
            config['default_profile'] = list(config['profiles'].keys())[0] if config['profiles'] else None

        self._save_config(config)
        print(f"âœ“ Profile '{name}' removed")

    def get_profile(self, name: Optional[str] = None) -> Dict[str, Any]:
        """Get a profile by name or default"""
        config = self._load_config()

        if name is None:
            name = config['default_profile']
            if name is None:
                print("Error: No default profile set and no profile specified")
                sys.exit(1)

        if name not in config['profiles']:
            print(f"Error: Profile '{name}' not found")
            print(f"Available profiles: {', '.join(config['profiles'].keys())}")
            sys.exit(1)

        return config['profiles'][name]

    def set_default(self, name: str):
        """Set default profile"""
        config = self._load_config()

        if name not in config['profiles']:
            print(f"Error: Profile '{name}' not found")
            sys.exit(1)

        config['default_profile'] = name
        self._save_config(config)
        print(f"âœ“ Default profile set to '{name}'")

    def clone_profile(self, source: str, destination: str):
        """Clone an existing profile"""
        config = self._load_config()

        if source not in config['profiles']:
            print(f"Error: Profile '{source}' not found")
            sys.exit(1)

        if destination in config['profiles']:
            response = input(f"Profile '{destination}' already exists. Overwrite? (y/n): ")
            if response.lower() != 'y':
                print("Aborted.")
                return

        config['profiles'][destination] = config['profiles'][source].copy()
        if 'models' in config['profiles'][destination]:
            config['profiles'][destination]['models'] = config['profiles'][source]['models'].copy()

        self._save_config(config)
        print(f"âœ“ Profile '{source}' cloned to '{destination}'")

    def export_profile(self, name: str, output_file: Optional[str] = None):
        """Export a profile to JSON"""
        config = self._load_config()

        if name not in config['profiles']:
            print(f"Error: Profile '{name}' not found")
            sys.exit(1)

        profile_data = {
            "name": name,
            "profile": config['profiles'][name],
            "exported_at": datetime.now().isoformat(),
            "version": VERSION
        }

        if output_file:
            with open(output_file, 'w') as f:
                json.dump(profile_data, f, indent=2)
            print(f"âœ“ Profile '{name}' exported to {output_file}")
        else:
            print(json.dumps(profile_data, indent=2))

    def import_profile(self, input_file: str, new_name: Optional[str] = None):
        """Import a profile from JSON"""
        try:
            with open(input_file, 'r') as f:
                profile_data = json.load(f)
        except FileNotFoundError:
            print(f"Error: File '{input_file}' not found")
            sys.exit(1)
        except json.JSONDecodeError:
            print(f"Error: Invalid JSON in '{input_file}'")
            sys.exit(1)

        name = new_name if new_name else profile_data.get('name', 'imported')
        config = self._load_config()

        if name in config['profiles']:
            response = input(f"Profile '{name}' already exists. Overwrite? (y/n): ")
            if response.lower() != 'y':
                print("Aborted.")
                return

        config['profiles'][name] = profile_data['profile']
        self._save_config(config)
        print(f"âœ“ Profile imported as '{name}'")

    def validate_profile(self, name: str):
        """Validate a profile's configuration"""
        config = self._load_config()

        if name not in config['profiles']:
            print(f"Error: Profile '{name}' not found")
            sys.exit(1)

        profile = config['profiles'][name]
        print(f"\n=== Validating profile: {name} ===\n")

        # Check API key
        if 'api_key' in profile and profile['api_key']:
            key_len = len(profile['api_key'])
            masked_key = profile['api_key'][:8] + '...' + profile['api_key'][-4:] if key_len > 12 else '***'
            print(f"âœ“ API Key: {masked_key} ({key_len} characters)")
        else:
            print("âš  API Key: Not set")

        # Check base URL
        if 'base_url' in profile and profile['base_url']:
            url = profile['base_url']
            try:
                parsed = urlparse(url)
                if parsed.scheme in ['http', 'https'] and parsed.netloc:
                    print(f"âœ“ Base URL: {url}")
                else:
                    print(f"âš  Base URL: {url} (may be invalid)")
            except Exception:
                print(f"âš  Base URL: {url} (invalid format)")
        else:
            print("âœ“ Base URL: Using default (https://api.anthropic.com)")

        # Check models
        if 'models' in profile and profile['models']:
            print(f"âœ“ Models configured:")
            for tier, model in profile['models'].items():
                print(f"  - {tier}: {model}")
        else:
            print("âš  Models: Using defaults")

        print("\nâœ“ Profile validation complete")

    def show_env(self, name: str):
        """Show environment variables that would be set for a profile"""
        config = self._load_config()

        if name not in config['profiles']:
            print(f"Error: Profile '{name}' not found")
            sys.exit(1)

        profile = config['profiles'][name]
        print(f"\n=== Environment variables for profile: {name} ===\n")

        if 'api_key' in profile:
            key = profile['api_key']
            masked = key[:8] + '...' + key[-4:] if len(key) > 12 else '***'
            print(f"ANTHROPIC_API_KEY={masked}")

        if 'base_url' in profile and profile['base_url']:
            print(f"ANTHROPIC_BASE_URL={profile['base_url']}")

        if 'models' in profile:
            models = profile['models']
            if 'haiku' in models:
                print(f"ANTHROPIC_DEFAULT_HAIKU_MODEL={models['haiku']}")
            if 'sonnet' in models:
                print(f"ANTHROPIC_DEFAULT_SONNET_MODEL={models['sonnet']}")
            if 'opus' in models:
                print(f"ANTHROPIC_DEFAULT_OPUS_MODEL={models['opus']}")

        print()

    def backup_config(self):
        """Backup all profiles and settings"""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        backup_file = BACKUPS_DIR / f"backup_{timestamp}.json"

        config = self._load_config()
        backup_data = {
            "backup_date": datetime.now().isoformat(),
            "version": VERSION,
            "config": config
        }

        with open(backup_file, 'w') as f:
            json.dump(backup_data, f, indent=2)

        print(f"âœ“ Configuration backed up to {backup_file}")
        return backup_file

    def restore_config(self, backup_file: str):
        """Restore profiles from a backup"""
        try:
            with open(backup_file, 'r') as f:
                backup_data = json.load(f)
        except FileNotFoundError:
            print(f"Error: Backup file '{backup_file}' not found")
            sys.exit(1)
        except json.JSONDecodeError:
            print(f"Error: Invalid backup file format")
            sys.exit(1)

        print(f"\n=== Restoring from backup ===")
        print(f"Backup date: {backup_data.get('backup_date', 'Unknown')}")
        print(f"Profiles in backup: {len(backup_data['config']['profiles'])}")

        response = input("\nThis will overwrite current configuration. Continue? (y/n): ")
        if response.lower() != 'y':
            print("Aborted.")
            return

        self._save_config(backup_data['config'])
        print("âœ“ Configuration restored successfully")

    def list_backups(self):
        """List all available backups"""
        backups = sorted(BACKUPS_DIR.glob("backup_*.json"), reverse=True)

        if not backups:
            print("No backups found")
            return

        print("\n=== Available Backups ===\n")
        for backup in backups:
            try:
                with open(backup, 'r') as f:
                    data = json.load(f)
                backup_date = data.get('backup_date', 'Unknown')
                num_profiles = len(data.get('config', {}).get('profiles', {}))
                print(f"â€¢ {backup.name}")
                print(f"  Date: {backup_date}")
                print(f"  Profiles: {num_profiles}")
                print(f"  Path: {backup}")
                print()
            except Exception as e:
                print(f"â€¢ {backup.name} (corrupted: {e})")
                print()


class AliasManager:
    """Manage profile aliases"""

    def __init__(self):
        self.aliases_file = ALIASES_FILE
        self._ensure_aliases_exists()

    def _ensure_aliases_exists(self):
        if not self.aliases_file.exists():
            with open(self.aliases_file, 'w') as f:
                json.dump({"aliases": {}}, f)

    def _load_aliases(self) -> Dict[str, str]:
        with open(self.aliases_file, 'r') as f:
            return json.load(f)

    def _save_aliases(self, data: Dict[str, Any]):
        with open(self.aliases_file, 'w') as f:
            json.dump(data, f, indent=2)

    def add_alias(self, alias: str, profile: str):
        """Add an alias for a profile"""
        # Verify profile exists
        pm = ProfileManager()
        pm.get_profile(profile)  # This will exit if profile doesn't exist

        data = self._load_aliases()
        data['aliases'][alias] = profile
        self._save_aliases(data)
        print(f"âœ“ Alias '{alias}' -> '{profile}' created")

    def remove_alias(self, alias: str):
        """Remove an alias"""
        data = self._load_aliases()
        if alias in data['aliases']:
            del data['aliases'][alias]
            self._save_aliases(data)
            print(f"âœ“ Alias '{alias}' removed")
        else:
            print(f"Error: Alias '{alias}' not found")
            sys.exit(1)

    def list_aliases(self):
        """List all aliases"""
        data = self._load_aliases()
        if not data['aliases']:
            print("No aliases configured")
            return

        print("\n=== Aliases ===\n")
        for alias, profile in data['aliases'].items():
            print(f"  {alias} -> {profile}")
        print()

    def resolve_alias(self, name: str) -> str:
        """Resolve an alias to a profile name"""
        data = self._load_aliases()
        return data['aliases'].get(name, name)


class GroupManager:
    """Manage profile groups for launching multiple profiles at once"""

    def __init__(self):
        self.groups_file = GROUPS_FILE
        self._ensure_groups_exists()

    def _ensure_groups_exists(self):
        if not self.groups_file.exists():
            with open(self.groups_file, 'w') as f:
                json.dump({"groups": {}}, f)

    def _load_groups(self) -> Dict[str, Any]:
        with open(self.groups_file, 'r') as f:
            return json.load(f)

    def _save_groups(self, data: Dict[str, Any]):
        with open(self.groups_file, 'w') as f:
            json.dump(data, f, indent=2)

    def add_group(self, name: str, profiles: List[str], description: str = ""):
        """Add a new profile group"""
        # Verify all profiles exist
        pm = ProfileManager()
        config = pm._load_config()
        for profile in profiles:
            if profile not in config['profiles']:
                print(f"Error: Profile '{profile}' not found")
                print(f"Available profiles: {', '.join(config['profiles'].keys())}")
                sys.exit(1)

        data = self._load_groups()

        if name in data['groups']:
            response = input(f"Group '{name}' already exists. Overwrite? (y/n): ")
            if response.lower() != 'y':
                print("Aborted.")
                return

        data['groups'][name] = {
            "profiles": profiles,
            "description": description,
            "created_at": datetime.now().isoformat()
        }

        self._save_groups(data)
        print(f"âœ“ Group '{name}' created with {len(profiles)} profile(s)")

    def remove_group(self, name: str):
        """Remove a profile group"""
        data = self._load_groups()
        if name in data['groups']:
            del data['groups'][name]
            self._save_groups(data)
            print(f"âœ“ Group '{name}' removed")
        else:
            print(f"Error: Group '{name}' not found")
            sys.exit(1)

    def list_groups(self):
        """List all profile groups"""
        data = self._load_groups()
        if not data['groups']:
            print("No groups configured")
            print("Use 'claude-switcher group add <name> --profiles <profile1,profile2,...>' to create one")
            return

        print("\n=== Profile Groups ===\n")
        for name, group in data['groups'].items():
            print(f"â€¢ {name}")
            if group.get('description'):
                print(f"  Description: {group['description']}")
            print(f"  Profiles: {', '.join(group['profiles'])}")
            print(f"  Created: {group.get('created_at', 'N/A')}")
            print()

    def get_group(self, name: str) -> Dict[str, Any]:
        """Get a group by name"""
        data = self._load_groups()
        if name not in data['groups']:
            print(f"Error: Group '{name}' not found")
            print(f"Available groups: {', '.join(data['groups'].keys())}")
            sys.exit(1)
        return data['groups'][name]

    def launch_group(self, name: str, extra_args: list = None):
        """Launch all profiles in a group"""
        group = self.get_group(name)
        profiles = group['profiles']

        if not profiles:
            print(f"Error: Group '{name}' has no profiles")
            sys.exit(1)

        print(f"\nðŸš€ Launching group '{name}' with {len(profiles)} profile(s)...\n")

        manager = ProfileManager()
        session_mgr = SessionManager()
        launched_pids = []

        for profile_name in profiles:
            profile = manager.get_profile(profile_name)

            # Build environment
            env = os.environ.copy()

            # Set API credentials
            if 'api_key' in profile:
                env['ANTHROPIC_API_KEY'] = profile['api_key']

            # Set base URL
            if 'base_url' in profile and profile['base_url']:
                env['ANTHROPIC_BASE_URL'] = profile['base_url']

            # Set model mappings
            if 'models' in profile:
                models = profile['models']
                if 'haiku' in models:
                    env['ANTHROPIC_DEFAULT_HAIKU_MODEL'] = models['haiku']
                if 'sonnet' in models:
                    env['ANTHROPIC_DEFAULT_SONNET_MODEL'] = models['sonnet']
                if 'opus' in models:
                    env['ANTHROPIC_DEFAULT_OPUS_MODEL'] = models['opus']

            # Build command
            cmd = ['claude']
            if extra_args:
                cmd.extend(extra_args)

            print(f"  âœ“ Launching {profile_name}...")
            Logger.log('group_session_start', profile_name, {'group': name, 'cwd': os.getcwd()})

            try:
                # Launch in background
                proc = subprocess.Popen(
                    cmd,
                    env=env,
                    stdout=subprocess.DEVNULL,
                    stderr=subprocess.DEVNULL,
                    start_new_session=True  # Detach from parent
                )

                # Track session
                session_mgr.add_session(proc.pid, f"{name}:{profile_name}")
                launched_pids.append((profile_name, proc.pid))

            except FileNotFoundError:
                print(f"  âœ— Error: 'claude' command not found. Is Claude Code installed?")
                sys.exit(1)
            except Exception as e:
                print(f"  âœ— Error launching {profile_name}: {e}")

        print(f"\nâœ“ Group '{name}' launched successfully!\n")
        print("Active sessions:")
        for profile_name, pid in launched_pids:
            print(f"  â€¢ {profile_name}: PID {pid}")
        print(f"\nUse 'claude-switcher session list' to view all sessions")
        print(f"Use 'claude-switcher session kill <pid>' to stop a session")


class SessionManager:
    """Manage active Claude Code sessions"""

    def __init__(self):
        self.sessions_file = SESSIONS_FILE
        self._ensure_sessions_exists()

    def _ensure_sessions_exists(self):
        if not self.sessions_file.exists():
            with open(self.sessions_file, 'w') as f:
                json.dump({"sessions": []}, f)

    def _load_sessions(self) -> Dict[str, Any]:
        with open(self.sessions_file, 'r') as f:
            return json.load(f)

    def _save_sessions(self, data: Dict[str, Any]):
        with open(self.sessions_file, 'w') as f:
            json.dump(data, f, indent=2)

    def add_session(self, pid: int, profile: str):
        """Track a new session"""
        data = self._load_sessions()
        session = {
            "pid": pid,
            "profile": profile,
            "started_at": datetime.now().isoformat(),
            "cwd": os.getcwd()
        }
        data['sessions'].append(session)
        self._save_sessions(data)

    def remove_session(self, pid: int):
        """Remove a session"""
        data = self._load_sessions()
        data['sessions'] = [s for s in data['sessions'] if s['pid'] != pid]
        self._save_sessions(data)

    def list_sessions(self):
        """List all tracked sessions"""
        data = self._load_sessions()
        active_sessions = []

        # Clean up dead sessions
        for session in data['sessions']:
            try:
                os.kill(session['pid'], 0)  # Check if process exists
                active_sessions.append(session)
            except OSError:
                pass  # Process is dead

        # Update sessions file
        data['sessions'] = active_sessions
        self._save_sessions(data)

        if not active_sessions:
            print("No active sessions")
            return

        print("\n=== Active Sessions ===\n")
        for session in active_sessions:
            print(f"â€¢ PID: {session['pid']}")
            print(f"  Profile: {session['profile']}")
            print(f"  Started: {session['started_at']}")
            print(f"  Directory: {session.get('cwd', 'N/A')}")
            print()

    def kill_session(self, pid: int):
        """Kill a session by PID"""
        try:
            os.kill(pid, signal.SIGTERM)
            self.remove_session(pid)
            print(f"âœ“ Session {pid} terminated")
        except OSError as e:
            print(f"Error: Could not kill session {pid}: {e}")
            sys.exit(1)


class WorkspaceManager:
    """Manage workspace-specific profiles"""

    @staticmethod
    def init_workspace(profile: str):
        """Initialize workspace with a default profile"""
        workspace_file = Path(WORKSPACE_FILE)
        if workspace_file.exists():
            response = input(f"Workspace config already exists. Overwrite? (y/n): ")
            if response.lower() != 'y':
                print("Aborted.")
                return

        # Verify profile exists
        pm = ProfileManager()
        pm.get_profile(profile)

        workspace_config = {
            "profile": profile,
            "created_at": datetime.now().isoformat()
        }

        with open(workspace_file, 'w') as f:
            json.dump(workspace_config, f, indent=2)

        print(f"âœ“ Workspace initialized with profile '{profile}'")
        print(f"  Config saved to: {workspace_file.absolute()}")

    @staticmethod
    def get_workspace_profile() -> Optional[str]:
        """Get the profile for the current workspace"""
        workspace_file = Path(WORKSPACE_FILE)
        if workspace_file.exists():
            try:
                with open(workspace_file, 'r') as f:
                    config = json.load(f)
                    return config.get('profile')
            except Exception:
                pass
        return None

    @staticmethod
    def remove_workspace():
        """Remove workspace configuration"""
        workspace_file = Path(WORKSPACE_FILE)
        if workspace_file.exists():
            workspace_file.unlink()
            print("âœ“ Workspace configuration removed")
        else:
            print("No workspace configuration found")


class Logger:
    """Log session activity"""

    @staticmethod
    def log(event_type: str, profile: str, details: Optional[Dict[str, Any]] = None):
        """Log an event"""
        log_file = LOGS_DIR / f"activity_{datetime.now().strftime('%Y%m')}.log"

        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "event": event_type,
            "profile": profile,
            "details": details or {}
        }

        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')

    @staticmethod
    def show_logs(limit: int = 50):
        """Show recent log entries"""
        all_logs = []

        for log_file in sorted(LOGS_DIR.glob("activity_*.log")):
            with open(log_file, 'r') as f:
                for line in f:
                    try:
                        all_logs.append(json.loads(line.strip()))
                    except json.JSONDecodeError:
                        pass

        if not all_logs:
            print("No logs found")
            return

        recent_logs = all_logs[-limit:]
        print(f"\n=== Recent Activity (last {len(recent_logs)} entries) ===\n")

        for log in recent_logs:
            timestamp = log['timestamp'].split('T')[0] + ' ' + log['timestamp'].split('T')[1][:8]
            print(f"[{timestamp}] {log['event']}: {log['profile']}")
            if log.get('details'):
                for key, value in log['details'].items():
                    print(f"  {key}: {value}")
        print()

    @staticmethod
    def clear_logs():
        """Clear all logs"""
        response = input("This will delete all log files. Continue? (y/n): ")
        if response.lower() != 'y':
            print("Aborted.")
            return

        for log_file in LOGS_DIR.glob("activity_*.log"):
            log_file.unlink()

        print("âœ“ All logs cleared")

    @staticmethod
    def stats():
        """Show usage statistics"""
        profile_count = {}
        total_sessions = 0

        for log_file in LOGS_DIR.glob("activity_*.log"):
            with open(log_file, 'r') as f:
                for line in f:
                    try:
                        log = json.loads(line.strip())
                        if log['event'] == 'session_start':
                            total_sessions += 1
                            profile = log['profile']
                            profile_count[profile] = profile_count.get(profile, 0) + 1
                    except json.JSONDecodeError:
                        pass

        if total_sessions == 0:
            print("No session statistics available")
            return

        print(f"\n=== Usage Statistics ===\n")
        print(f"Total sessions: {total_sessions}\n")
        print("Sessions by profile:")

        for profile, count in sorted(profile_count.items(), key=lambda x: x[1], reverse=True):
            percentage = (count / total_sessions) * 100
            print(f"  {profile}: {count} ({percentage:.1f}%)")
        print()


class UpdateChecker:
    """Check for new versions of claude-switcher"""

    @staticmethod
    def check_for_updates(silent: bool = False) -> Optional[str]:
        """
        Check GitHub for the latest release
        Returns the latest version if an update is available, None otherwise
        """
        try:
            import urllib.request
            import ssl

            # Create SSL context
            context = ssl.create_default_context()

            # Fetch latest release from GitHub API
            url = f"https://api.github.com/repos/{GITHUB_REPO}/releases/latest"
            req = urllib.request.Request(url)
            req.add_header('Accept', 'application/vnd.github.v3+json')

            with urllib.request.urlopen(req, context=context, timeout=5) as response:
                data = json.loads(response.read().decode())
                latest_version = data.get('tag_name', '').lstrip('v')
                release_url = data.get('html_url', '')
                release_notes = data.get('body', '')

                if not latest_version:
                    if not silent:
                        print("Could not determine latest version")
                    return None

                # Compare versions
                current = tuple(map(int, VERSION.split('.')))
                latest = tuple(map(int, latest_version.split('.')))

                if latest > current:
                    if not silent:
                        print(f"\n{'='*60}")
                        print(f"ðŸŽ‰ Update Available!")
                        print(f"{'='*60}")
                        print(f"Current version: v{VERSION}")
                        print(f"Latest version:  v{latest_version}")
                        print(f"\nRelease URL: {release_url}")
                        if release_notes:
                            print(f"\nRelease Notes:\n{release_notes[:500]}...")
                        print(f"\nTo update, run:")
                        print(f"  cd {Path(__file__).parent if Path(__file__).parent.exists() else '~/claude-code-switcher'}")
                        print(f"  git pull origin main")
                        print(f"  ./install.sh")
                        print(f"{'='*60}\n")
                    return latest_version
                else:
                    if not silent:
                        print(f"âœ“ You're running the latest version (v{VERSION})")
                    return None

        except urllib.error.URLError as e:
            if not silent:
                print(f"Could not check for updates: Network error ({e.reason})")
            return None
        except Exception as e:
            if not silent:
                print(f"Could not check for updates: {e}")
            return None

    @staticmethod
    def auto_check():
        """
        Perform automatic update check (silent if up-to-date)
        Only runs once per day
        """
        last_check_file = CONFIG_DIR / ".last_update_check"

        # Check if we've already checked today
        if last_check_file.exists():
            try:
                with open(last_check_file, 'r') as f:
                    last_check = datetime.fromisoformat(f.read().strip())
                    if (datetime.now() - last_check).days < 1:
                        return  # Don't check more than once per day
            except Exception:
                pass

        # Check for updates silently
        new_version = UpdateChecker.check_for_updates(silent=True)

        # Update last check time
        with open(last_check_file, 'w') as f:
            f.write(datetime.now().isoformat())

        # Show notification if update available
        if new_version:
            print(f"ðŸ’¡ Update available: v{VERSION} â†’ v{new_version}")
            print(f"   Run 'claude-switcher update check' for details\n")


class ModelUpdater:
    """Fetch and update model names from Anthropic API"""

    # Known model mappings for different providers
    KNOWN_MODELS = {
        'anthropic': {
            'haiku': 'claude-3-5-haiku-20241022',
            'sonnet': 'claude-sonnet-4-5-20250929',
            'opus': 'claude-opus-4-20250514'
        },
        'zai': {
            'haiku': 'GLM-4.5-Air',
            'sonnet': 'GLM-4.6',
            'opus': 'GLM-4.6'
        }
    }

    @staticmethod
    def list_models(provider: str = 'anthropic'):
        """List available models for a provider"""
        if provider not in ModelUpdater.KNOWN_MODELS:
            print(f"Unknown provider: {provider}")
            print(f"Known providers: {', '.join(ModelUpdater.KNOWN_MODELS.keys())}")
            return

        models = ModelUpdater.KNOWN_MODELS[provider]
        print(f"\n=== Available Models ({provider}) ===\n")
        for tier, model in models.items():
            print(f"  {tier}: {model}")
        print()

    @staticmethod
    def update_profile_models(profile_name: str, provider: str = 'anthropic', dry_run: bool = False):
        """Update a profile's model mappings to latest known models"""
        manager = ProfileManager()
        config = manager._load_config()

        if profile_name not in config['profiles']:
            print(f"Error: Profile '{profile_name}' not found")
            sys.exit(1)

        if provider not in ModelUpdater.KNOWN_MODELS:
            print(f"Error: Unknown provider '{provider}'")
            print(f"Known providers: {', '.join(ModelUpdater.KNOWN_MODELS.keys())}")
            sys.exit(1)

        profile = config['profiles'][profile_name]
        latest_models = ModelUpdater.KNOWN_MODELS[provider]

        print(f"\n=== Updating models for profile: {profile_name} ===\n")

        if 'models' not in profile:
            profile['models'] = {}

        changes = []
        for tier, new_model in latest_models.items():
            old_model = profile['models'].get(tier, 'Not set')
            if old_model != new_model:
                changes.append((tier, old_model, new_model))
                if not dry_run:
                    profile['models'][tier] = new_model

        if not changes:
            print("âœ“ Profile already has latest models")
            return

        print("Changes to be made:" if dry_run else "Changes made:")
        for tier, old, new in changes:
            print(f"  {tier}:")
            print(f"    Old: {old}")
            print(f"    New: {new}")

        if not dry_run:
            manager._save_config(config)
            print(f"\nâœ“ Profile '{profile_name}' updated with latest {provider} models")
        else:
            print(f"\n(Dry run - no changes made)")
            print(f"Run without --dry-run to apply changes")


class ProfileHealthChecker:
    """Test profile configurations for connectivity and validity"""

    @staticmethod
    def test_profile(profile_name: str, verbose: bool = False) -> bool:
        """Test a single profile's configuration"""
        manager = ProfileManager()

        try:
            profile = manager.get_profile(profile_name)
        except SystemExit:
            return False

        print(f"\n=== Testing profile: {profile_name} ===\n")

        # Check API key
        has_key = 'api_key' in profile and profile['api_key']
        if has_key:
            key_len = len(profile['api_key'])
            print(f"âœ“ API Key: Present ({key_len} characters)")
        else:
            print(f"âœ— API Key: Missing")
            return False

        # Check base URL
        base_url = profile.get('base_url', 'https://api.anthropic.com')
        try:
            parsed = urlparse(base_url)
            if parsed.scheme in ['http', 'https'] and parsed.netloc:
                print(f"âœ“ Base URL: {base_url}")
            else:
                print(f"âœ— Base URL: Invalid format ({base_url})")
                return False
        except Exception:
            print(f"âœ— Base URL: Invalid ({base_url})")
            return False

        # Check models
        if 'models' in profile and profile['models']:
            print(f"âœ“ Models: {len(profile['models'])} configured")
            if verbose:
                for tier, model in profile['models'].items():
                    print(f"    {tier}: {model}")
        else:
            print(f"âš  Models: None configured (will use defaults)")

        # Try a simple API connection test
        if verbose:
            print(f"\nTesting API connection...")
            try:
                import urllib.request
                import ssl

                context = ssl.create_default_context()
                url = f"{base_url.rstrip('/')}/v1/messages"
                req = urllib.request.Request(url, method='POST')
                req.add_header('x-api-key', profile['api_key'])
                req.add_header('anthropic-version', '2023-06-01')
                req.add_header('content-type', 'application/json')

                # Send minimal request just to test auth
                data = json.dumps({
                    "model": profile.get('models', {}).get('haiku', 'claude-3-haiku-20240307'),
                    "max_tokens": 1,
                    "messages": [{"role": "user", "content": "test"}]
                }).encode()

                try:
                    with urllib.request.urlopen(req, data, context=context, timeout=10) as response:
                        print(f"âœ“ API Connection: Success ({response.status})")
                        return True
                except urllib.error.HTTPError as e:
                    if e.code == 400:
                        # Bad request is OK - means auth worked
                        print(f"âœ“ API Connection: Authenticated")
                        return True
                    elif e.code == 401:
                        print(f"âœ— API Connection: Invalid API key")
                        return False
                    else:
                        print(f"âš  API Connection: HTTP {e.code}")
                        return True  # Key is valid even if request had issues
            except Exception as e:
                print(f"âš  API Connection: Could not test ({e})")

        print(f"\nâœ“ Profile configuration is valid")
        return True

    @staticmethod
    def test_all_profiles(verbose: bool = False):
        """Test all profiles"""
        manager = ProfileManager()
        config = manager._load_config()

        if not config['profiles']:
            print("No profiles configured")
            return

        print(f"\n=== Testing {len(config['profiles'])} profile(s) ===")

        results = {}
        for name in config['profiles']:
            results[name] = ProfileHealthChecker.test_profile(name, verbose)

        # Summary
        passed = sum(1 for v in results.values() if v)
        total = len(results)

        print(f"\n=== Summary ===")
        print(f"Passed: {passed}/{total}")

        if passed < total:
            print(f"\nFailed profiles:")
            for name, passed in results.items():
                if not passed:
                    print(f"  â€¢ {name}")


class TemplateManager:
    """Manage profile templates for quick setup"""

    TEMPLATES = {
        'anthropic': {
            'name': 'Anthropic Claude',
            'description': 'Official Anthropic API with latest Claude models',
            'base_url': 'https://api.anthropic.com',
            'models': {
                'haiku': 'claude-3-5-haiku-20241022',
                'sonnet': 'claude-sonnet-4-5-20250929',
                'opus': 'claude-opus-4-20250514'
            }
        },
        'zai-glm': {
            'name': 'Z.AI GLM',
            'description': 'Z.AI GLM models via Anthropic-compatible API',
            'base_url': 'https://api.z.ai/api/anthropic',
            'models': {
                'haiku': 'GLM-4.5-Air',
                'sonnet': 'GLM-4.6',
                'opus': 'GLM-4.6'
            }
        },
        'deepseek': {
            'name': 'DeepSeek',
            'description': 'DeepSeek AI models',
            'base_url': 'https://api.deepseek.com',
            'models': {
                'sonnet': 'deepseek-chat'
            }
        }
    }

    @staticmethod
    def list_templates():
        """List all available templates"""
        print("\n=== Available Profile Templates ===\n")
        for template_id, template in TemplateManager.TEMPLATES.items():
            print(f"â€¢ {template_id}")
            print(f"  Name: {template['name']}")
            print(f"  Description: {template['description']}")
            print(f"  Base URL: {template['base_url']}")
            print(f"  Models: {', '.join(template['models'].keys())}")
            print()

    @staticmethod
    def show_template(template_id: str):
        """Show details of a specific template"""
        if template_id not in TemplateManager.TEMPLATES:
            print(f"Error: Template '{template_id}' not found")
            print(f"Available templates: {', '.join(TemplateManager.TEMPLATES.keys())}")
            sys.exit(1)

        template = TemplateManager.TEMPLATES[template_id]
        print(f"\n=== Template: {template_id} ===\n")
        print(f"Name: {template['name']}")
        print(f"Description: {template['description']}")
        print(f"\nConfiguration:")
        print(f"  Base URL: {template['base_url']}")
        print(f"\nModels:")
        for tier, model in template['models'].items():
            print(f"  {tier}: {model}")
        print()

    @staticmethod
    def use_template(template_id: str, profile_name: str, api_key: Optional[str] = None):
        """Create a profile from a template"""
        if template_id not in TemplateManager.TEMPLATES:
            print(f"Error: Template '{template_id}' not found")
            print(f"Available templates: {', '.join(TemplateManager.TEMPLATES.keys())}")
            sys.exit(1)

        template = TemplateManager.TEMPLATES[template_id]

        print(f"\n=== Creating profile from template: {template_id} ===\n")
        print(f"Template: {template['name']}")
        print(f"Description: {template['description']}")
        print()

        # Get API key if not provided
        if not api_key:
            api_key = input("Enter your API key: ").strip()
            if not api_key:
                print("Error: API key is required")
                sys.exit(1)

        # Create profile
        manager = ProfileManager()
        config = manager._load_config()

        if profile_name in config['profiles']:
            response = input(f"Profile '{profile_name}' already exists. Overwrite? (y/n): ")
            if response.lower() != 'y':
                print("Aborted.")
                return

        config['profiles'][profile_name] = {
            'api_key': api_key,
            'base_url': template['base_url'],
            'models': template['models'].copy()
        }

        # Set as default if it's the first profile
        if not config['default_profile']:
            config['default_profile'] = profile_name
            print(f"Set '{profile_name}' as default profile")

        manager._save_config(config)

        print(f"\nâœ“ Profile '{profile_name}' created successfully from template '{template_id}'!")
        print(f"\nConfiguration:")
        print(f"  Base URL: {template['base_url']}")
        print(f"  Models: {', '.join(f'{k}={v}' for k, v in template['models'].items())}")
        print(f"\nUse 'claude-switcher start {profile_name}' to launch")


def launch_session(profile_name: Optional[str] = None, extra_args: list = None):
    """Launch Claude Code with the specified profile"""
    manager = ProfileManager()
    alias_manager = AliasManager()

    # Check for workspace profile first
    if profile_name is None:
        workspace_profile = WorkspaceManager.get_workspace_profile()
        if workspace_profile:
            print(f"ðŸ“ Using workspace profile: {workspace_profile}")
            profile_name = workspace_profile

    # Resolve alias if provided
    if profile_name:
        resolved_name = alias_manager.resolve_alias(profile_name)
        if resolved_name != profile_name:
            print(f"ðŸ”— Resolved alias '{profile_name}' -> '{resolved_name}'")
            profile_name = resolved_name

    profile = manager.get_profile(profile_name)

    # Build environment
    env = os.environ.copy()

    # Set API credentials
    if 'api_key' in profile:
        env['ANTHROPIC_API_KEY'] = profile['api_key']

    # Set base URL
    if 'base_url' in profile and profile['base_url']:
        env['ANTHROPIC_BASE_URL'] = profile['base_url']

    # Set model mappings
    if 'models' in profile:
        models = profile['models']
        if 'haiku' in models:
            env['ANTHROPIC_DEFAULT_HAIKU_MODEL'] = models['haiku']
        if 'sonnet' in models:
            env['ANTHROPIC_DEFAULT_SONNET_MODEL'] = models['sonnet']
        if 'opus' in models:
            env['ANTHROPIC_DEFAULT_OPUS_MODEL'] = models['opus']

    # Build command
    cmd = ['claude']
    if extra_args:
        cmd.extend(extra_args)

    profile_display = profile_name or manager._load_config()['default_profile']
    print(f"ðŸš€ Launching Claude Code with profile: {profile_display}")
    print(f"   Base URL: {profile.get('base_url', 'default')}")
    print()

    # Log session start
    Logger.log('session_start', profile_display, {'cwd': os.getcwd()})

    # Launch Claude Code
    try:
        proc = subprocess.Popen(cmd, env=env)

        # Track session
        session_mgr = SessionManager()
        session_mgr.add_session(proc.pid, profile_display)

        # Wait for process to complete
        proc.wait()

        # Remove session when done
        session_mgr.remove_session(proc.pid)
        Logger.log('session_end', profile_display)

    except KeyboardInterrupt:
        print("\n\nSession terminated.")
        Logger.log('session_interrupted', profile_display)
    except FileNotFoundError:
        print("Error: 'claude' command not found. Is Claude Code installed?")
        sys.exit(1)


def print_usage():
    """Print usage information"""
    print(f"""
Claude Code Switcher v{VERSION} - Manage multiple model profiles and launch isolated sessions

USAGE:
    claude-switcher start [profile] [--args]      Launch Claude Code with a profile
    claude-switcher profile <command> [args]      Manage profiles
    claude-switcher template <command> [args]     Use profile templates (NEW in v2.2)
    claude-switcher models <command> [args]       List and manage models (NEW in v2.2)
    claude-switcher alias <command> [args]        Manage profile aliases
    claude-switcher group <command> [args]        Manage profile groups
    claude-switcher session <command> [args]      Manage active sessions
    claude-switcher workspace <command> [args]    Manage workspace profiles
    claude-switcher backup <command> [args]       Backup and restore configuration
    claude-switcher logs <command> [args]         View logs and statistics
    claude-switcher update <command>              Check for updates
    claude-switcher version                       Show version
    claude-switcher help                          Show this help

PROFILE COMMANDS:
    add <name>              Add a new profile
    list                    List all profiles
    remove <name>           Remove a profile
    default <name>          Set default profile
    clone <src> <dst>       Clone a profile
    export <name> [file]    Export profile to JSON
    import <file> [name]    Import profile from JSON
    validate <name>         Validate profile configuration
    env <name>              Show environment variables for profile
    test <name> [--verbose] Test profile connectivity (NEW in v2.2)
    test --all [--verbose]  Test all profiles (NEW in v2.2)
    update-models <name>    Update profile to latest models (NEW in v2.2)

TEMPLATE COMMANDS (NEW in v2.2):
    list                    List all available templates
    show <template>         Show template details
    use <template> <name>   Create profile from template

MODELS COMMANDS (NEW in v2.2):
    list [--provider]       List available models
    update <profile>        Update profile to latest models

ALIAS COMMANDS:
    add <alias> <profile>   Create an alias for a profile
    remove <alias>          Remove an alias
    list                    List all aliases

GROUP COMMANDS:
    add <name> --profiles <p1,p2,...> [--desc "..."]    Create a profile group
    remove <name>                                       Remove a group
    list                                                List all groups
    launch <name>                                       Launch all profiles in a group

SESSION COMMANDS:
    list                    List active sessions
    kill <pid>              Terminate a session

WORKSPACE COMMANDS:
    init <profile>          Initialize workspace with a profile
    remove                  Remove workspace configuration

BACKUP COMMANDS:
    create                  Create a backup of all profiles
    restore <file>          Restore from a backup
    list                    List all available backups

LOG COMMANDS:
    show [limit]            Show recent activity (default: 50 entries)
    clear                   Clear all logs
    stats                   Show usage statistics

UPDATE COMMANDS:
    check                   Check for new versions

EXAMPLES:
    # Basic usage
    claude-switcher profile add claude
    claude-switcher start claude

    # Quick setup with templates (NEW in v2.2)
    claude-switcher template list
    claude-switcher template use anthropic my-claude
    claude-switcher template use zai-glm glm

    # Test profiles (NEW in v2.2)
    claude-switcher profile test claude
    claude-switcher profile test --all --verbose

    # Update models (NEW in v2.2)
    claude-switcher models list
    claude-switcher profile update-models claude
    claude-switcher models update claude --provider anthropic

    # Using aliases
    claude-switcher alias add c claude
    claude-switcher start c

    # Using profile groups (NEW in v2.1)
    claude-switcher group add dev --profiles claude,glm --desc "Development profiles"
    claude-switcher group launch dev  # Launches both Claude and GLM sessions

    # Workspace-specific profiles
    cd ~/my-project
    claude-switcher workspace init glm
    claude-switcher start  # Automatically uses glm profile

    # Profile management
    claude-switcher profile clone claude claude-test
    claude-switcher profile validate glm
    claude-switcher profile env claude

    # Session management
    claude-switcher session list
    claude-switcher session kill 12345

    # Backup and restore
    claude-switcher backup create
    claude-switcher backup list
    claude-switcher backup restore ~/.claude-switcher/backups/backup_20251107_120000.json

    # View logs and stats
    claude-switcher logs show 100
    claude-switcher logs stats

    # Check for updates (NEW in v2.1)
    claude-switcher update check

DATA LOCATIONS:
    Profiles:  ~/.claude-switcher/profiles.json
    Aliases:   ~/.claude-switcher/aliases.json
    Groups:    ~/.claude-switcher/groups.json
    Sessions:  ~/.claude-switcher/sessions.json
    Logs:      ~/.claude-switcher/logs/
    Backups:   ~/.claude-switcher/backups/
    Workspace: ./.claude-switcher.json (per-directory)
""")


def main():
    if len(sys.argv) < 2:
        print_usage()
        sys.exit(0)

    command = sys.argv[1]

    if command in ['help', '--help', '-h']:
        print_usage()

    elif command in ['version', '--version', '-v']:
        print(f"Claude Code Switcher v{VERSION}")

    elif command == 'start':
        # Check for updates automatically (once per day)
        UpdateChecker.auto_check()

        profile = sys.argv[2] if len(sys.argv) > 2 and not sys.argv[2].startswith('-') else None
        extra_args = sys.argv[3:] if profile else sys.argv[2:]
        launch_session(profile, extra_args)

    elif command == 'profile':
        if len(sys.argv) < 3:
            print("Error: Missing profile subcommand")
            print("Use: claude-switcher profile [add|list|remove|default|clone|export|import|validate|env]")
            sys.exit(1)

        subcommand = sys.argv[2]
        manager = ProfileManager()

        if subcommand == 'add':
            if len(sys.argv) < 4:
                print("Error: Missing profile name")
                print("Use: claude-switcher profile add <name>")
                sys.exit(1)
            manager.add_profile(sys.argv[3])

        elif subcommand == 'list':
            manager.list_profiles()

        elif subcommand == 'remove':
            if len(sys.argv) < 4:
                print("Error: Missing profile name")
                sys.exit(1)
            manager.remove_profile(sys.argv[3])

        elif subcommand == 'default':
            if len(sys.argv) < 4:
                print("Error: Missing profile name")
                sys.exit(1)
            manager.set_default(sys.argv[3])

        elif subcommand == 'clone':
            if len(sys.argv) < 5:
                print("Error: Missing source and/or destination profile names")
                print("Use: claude-switcher profile clone <source> <destination>")
                sys.exit(1)
            manager.clone_profile(sys.argv[3], sys.argv[4])

        elif subcommand == 'export':
            if len(sys.argv) < 4:
                print("Error: Missing profile name")
                print("Use: claude-switcher profile export <name> [output-file]")
                sys.exit(1)
            output_file = sys.argv[4] if len(sys.argv) > 4 else None
            manager.export_profile(sys.argv[3], output_file)

        elif subcommand == 'import':
            if len(sys.argv) < 4:
                print("Error: Missing input file")
                print("Use: claude-switcher profile import <file> [name]")
                sys.exit(1)
            new_name = sys.argv[4] if len(sys.argv) > 4 else None
            manager.import_profile(sys.argv[3], new_name)

        elif subcommand == 'validate':
            if len(sys.argv) < 4:
                print("Error: Missing profile name")
                print("Use: claude-switcher profile validate <name>")
                sys.exit(1)
            manager.validate_profile(sys.argv[3])

        elif subcommand == 'env':
            if len(sys.argv) < 4:
                print("Error: Missing profile name")
                print("Use: claude-switcher profile env <name>")
                sys.exit(1)
            manager.show_env(sys.argv[3])

        elif subcommand == 'test':
            if len(sys.argv) < 4:
                print("Error: Missing profile name or --all flag")
                print("Use: claude-switcher profile test <name> [--verbose]")
                print("  or: claude-switcher profile test --all [--verbose]")
                sys.exit(1)

            if sys.argv[3] == '--all':
                verbose = '--verbose' in sys.argv[4:]
                ProfileHealthChecker.test_all_profiles(verbose)
            else:
                verbose = '--verbose' in sys.argv[4:]
                ProfileHealthChecker.test_profile(sys.argv[3], verbose)

        elif subcommand == 'update-models':
            if len(sys.argv) < 4:
                print("Error: Missing profile name")
                print("Use: claude-switcher profile update-models <name> [--provider <provider>] [--dry-run]")
                sys.exit(1)

            profile_name = sys.argv[3]
            provider = 'anthropic'
            dry_run = False

            # Parse optional arguments
            i = 4
            while i < len(sys.argv):
                if sys.argv[i] == '--provider' and i + 1 < len(sys.argv):
                    provider = sys.argv[i + 1]
                    i += 2
                elif sys.argv[i] == '--dry-run':
                    dry_run = True
                    i += 1
                else:
                    i += 1

            ModelUpdater.update_profile_models(profile_name, provider, dry_run)

        else:
            print(f"Error: Unknown profile subcommand: {subcommand}")
            sys.exit(1)

    elif command == 'template':
        if len(sys.argv) < 3:
            print("Error: Missing template subcommand")
            print("Use: claude-switcher template [list|show|use]")
            sys.exit(1)

        subcommand = sys.argv[2]

        if subcommand == 'list':
            TemplateManager.list_templates()

        elif subcommand == 'show':
            if len(sys.argv) < 4:
                print("Error: Missing template name")
                print("Use: claude-switcher template show <template>")
                sys.exit(1)
            TemplateManager.show_template(sys.argv[3])

        elif subcommand == 'use':
            if len(sys.argv) < 5:
                print("Error: Missing template and/or profile name")
                print("Use: claude-switcher template use <template> <profile-name> [--api-key <key>]")
                sys.exit(1)

            template_id = sys.argv[3]
            profile_name = sys.argv[4]
            api_key = None

            # Check for --api-key option
            if len(sys.argv) > 6 and sys.argv[5] == '--api-key':
                api_key = sys.argv[6]

            TemplateManager.use_template(template_id, profile_name, api_key)

        else:
            print(f"Error: Unknown template subcommand: {subcommand}")
            sys.exit(1)

    elif command == 'models':
        if len(sys.argv) < 3:
            print("Error: Missing models subcommand")
            print("Use: claude-switcher models [list|update]")
            sys.exit(1)

        subcommand = sys.argv[2]

        if subcommand == 'list':
            provider = 'anthropic'
            # Check for --provider option
            if len(sys.argv) > 3 and sys.argv[3] == '--provider' and len(sys.argv) > 4:
                provider = sys.argv[4]
            ModelUpdater.list_models(provider)

        elif subcommand == 'update':
            if len(sys.argv) < 4:
                print("Error: Missing profile name")
                print("Use: claude-switcher models update <profile> [--provider <provider>] [--dry-run]")
                sys.exit(1)

            profile_name = sys.argv[3]
            provider = 'anthropic'
            dry_run = False

            # Parse optional arguments
            i = 4
            while i < len(sys.argv):
                if sys.argv[i] == '--provider' and i + 1 < len(sys.argv):
                    provider = sys.argv[i + 1]
                    i += 2
                elif sys.argv[i] == '--dry-run':
                    dry_run = True
                    i += 1
                else:
                    i += 1

            ModelUpdater.update_profile_models(profile_name, provider, dry_run)

        else:
            print(f"Error: Unknown models subcommand: {subcommand}")
            sys.exit(1)

    elif command == 'alias':
        if len(sys.argv) < 3:
            print("Error: Missing alias subcommand")
            print("Use: claude-switcher alias [add|remove|list]")
            sys.exit(1)

        subcommand = sys.argv[2]
        alias_mgr = AliasManager()

        if subcommand == 'add':
            if len(sys.argv) < 5:
                print("Error: Missing alias and/or profile name")
                print("Use: claude-switcher alias add <alias> <profile>")
                sys.exit(1)
            alias_mgr.add_alias(sys.argv[3], sys.argv[4])

        elif subcommand == 'remove':
            if len(sys.argv) < 4:
                print("Error: Missing alias name")
                print("Use: claude-switcher alias remove <alias>")
                sys.exit(1)
            alias_mgr.remove_alias(sys.argv[3])

        elif subcommand == 'list':
            alias_mgr.list_aliases()

        else:
            print(f"Error: Unknown alias subcommand: {subcommand}")
            sys.exit(1)

    elif command == 'group':
        if len(sys.argv) < 3:
            print("Error: Missing group subcommand")
            print("Use: claude-switcher group [add|remove|list|launch]")
            sys.exit(1)

        subcommand = sys.argv[2]
        group_mgr = GroupManager()

        if subcommand == 'add':
            if len(sys.argv) < 4:
                print("Error: Missing group name")
                print("Use: claude-switcher group add <name> --profiles <profile1,profile2,...> [--desc \"description\"]")
                sys.exit(1)

            name = sys.argv[3]
            profiles = []
            description = ""

            # Parse arguments
            i = 4
            while i < len(sys.argv):
                if sys.argv[i] == '--profiles':
                    if i + 1 >= len(sys.argv):
                        print("Error: --profiles requires a value")
                        sys.exit(1)
                    profiles = sys.argv[i + 1].split(',')
                    i += 2
                elif sys.argv[i] == '--desc':
                    if i + 1 >= len(sys.argv):
                        print("Error: --desc requires a value")
                        sys.exit(1)
                    description = sys.argv[i + 1]
                    i += 2
                else:
                    print(f"Error: Unknown option: {sys.argv[i]}")
                    sys.exit(1)

            if not profiles:
                print("Error: --profiles is required")
                print("Use: claude-switcher group add <name> --profiles <profile1,profile2,...>")
                sys.exit(1)

            group_mgr.add_group(name, profiles, description)

        elif subcommand == 'remove':
            if len(sys.argv) < 4:
                print("Error: Missing group name")
                print("Use: claude-switcher group remove <name>")
                sys.exit(1)
            group_mgr.remove_group(sys.argv[3])

        elif subcommand == 'list':
            group_mgr.list_groups()

        elif subcommand == 'launch':
            if len(sys.argv) < 4:
                print("Error: Missing group name")
                print("Use: claude-switcher group launch <name>")
                sys.exit(1)
            extra_args = sys.argv[4:] if len(sys.argv) > 4 else None
            group_mgr.launch_group(sys.argv[3], extra_args)

        else:
            print(f"Error: Unknown group subcommand: {subcommand}")
            sys.exit(1)

    elif command == 'session':
        if len(sys.argv) < 3:
            print("Error: Missing session subcommand")
            print("Use: claude-switcher session [list|kill]")
            sys.exit(1)

        subcommand = sys.argv[2]
        session_mgr = SessionManager()

        if subcommand == 'list':
            session_mgr.list_sessions()

        elif subcommand == 'kill':
            if len(sys.argv) < 4:
                print("Error: Missing PID")
                print("Use: claude-switcher session kill <pid>")
                sys.exit(1)
            try:
                pid = int(sys.argv[3])
                session_mgr.kill_session(pid)
            except ValueError:
                print("Error: PID must be a number")
                sys.exit(1)

        else:
            print(f"Error: Unknown session subcommand: {subcommand}")
            sys.exit(1)

    elif command == 'workspace':
        if len(sys.argv) < 3:
            print("Error: Missing workspace subcommand")
            print("Use: claude-switcher workspace [init|remove]")
            sys.exit(1)

        subcommand = sys.argv[2]

        if subcommand == 'init':
            if len(sys.argv) < 4:
                print("Error: Missing profile name")
                print("Use: claude-switcher workspace init <profile>")
                sys.exit(1)
            WorkspaceManager.init_workspace(sys.argv[3])

        elif subcommand == 'remove':
            WorkspaceManager.remove_workspace()

        else:
            print(f"Error: Unknown workspace subcommand: {subcommand}")
            sys.exit(1)

    elif command == 'backup':
        if len(sys.argv) < 3:
            print("Error: Missing backup subcommand")
            print("Use: claude-switcher backup [create|restore|list]")
            sys.exit(1)

        subcommand = sys.argv[2]
        manager = ProfileManager()

        if subcommand == 'create':
            manager.backup_config()

        elif subcommand == 'restore':
            if len(sys.argv) < 4:
                print("Error: Missing backup file")
                print("Use: claude-switcher backup restore <file>")
                sys.exit(1)
            manager.restore_config(sys.argv[3])

        elif subcommand == 'list':
            manager.list_backups()

        else:
            print(f"Error: Unknown backup subcommand: {subcommand}")
            sys.exit(1)

    elif command == 'logs':
        if len(sys.argv) < 3:
            print("Error: Missing logs subcommand")
            print("Use: claude-switcher logs [show|clear|stats]")
            sys.exit(1)

        subcommand = sys.argv[2]

        if subcommand == 'show':
            limit = int(sys.argv[3]) if len(sys.argv) > 3 else 50
            Logger.show_logs(limit)

        elif subcommand == 'clear':
            Logger.clear_logs()

        elif subcommand == 'stats':
            Logger.stats()

        else:
            print(f"Error: Unknown logs subcommand: {subcommand}")
            sys.exit(1)

    elif command == 'update':
        if len(sys.argv) < 3:
            print("Error: Missing update subcommand")
            print("Use: claude-switcher update [check]")
            sys.exit(1)

        subcommand = sys.argv[2]

        if subcommand == 'check':
            UpdateChecker.check_for_updates(silent=False)

        else:
            print(f"Error: Unknown update subcommand: {subcommand}")
            sys.exit(1)

    else:
        print(f"Error: Unknown command: {command}")
        print("Use 'claude-switcher help' for usage information")
        sys.exit(1)


if __name__ == '__main__':
    main()
